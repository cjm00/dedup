#!/usr/bin/env python3

# This file must live in dedup/benchsuite! The file may be run from anywhere, but the script itself must reside in this subdirectory.

import os
import subprocess
import gzip
import argparse
import time
import platform
import shutil
import tempfile

from collections import defaultdict
from operator import itemgetter
from statistics import mean, pstdev

BENCH_FILE_PATH = os.path.abspath(__file__)
BENCH_DIR = os.path.dirname(BENCH_FILE_PATH)
PROJECT_PATH = os.path.abspath(os.path.join(os.path.dirname(__file__), os.path.pardir))

TEST_DIR =  "corpustest"
BLOB_NAME = "europarl.txt"
CORPUS_NAME_GZ = "en.raw.tar.gz"
CORPUS_UNPACK_DIR = os.path.join("Europarl", "raw", "en")
CORPUS_URL = "opus.nlpl.eu/download.php?f=Europarl/en.raw.tar.gz"

DEDUP_BIN_NAME = "dedup" + (".exe" if platform.system() == 'Windows' else "")
DEDUP_BIN_PATH = os.path.join(PROJECT_PATH, "target", "release", DEDUP_BIN_NAME)

SORT_PATH = "sort"

BLOB_PATH = ""

class MissingCommands(Exception):
    def __init__(self, missing_names):
        self.missing = missing_names

    def __str__(self):
        return "MissingCommands({})".format(repr(self.missing))

class Command():
    def __init__(self, name, cmd, *args, **kwargs):
        self.name = name
        self.cmd = cmd
        self.args = args
        self.kwargs = kwargs

    def exists(self):
        return shutil.which(self.binary_name) is not None

    @property
    def binary_name(self):
        return self.cmd[0]

    def run(self):
        return subprocess.run(self.cmd, *self.args, **self.kwargs)


class Benchmarker():
    def __init__(self, warmup=1, count=3, commands=None, directory=None, use_tempfile=False, count_lines=False):
        self.warmup = warmup
        self.count = count
        self.commands = commands or []
        self.directory = directory
        self.use_tempfile = use_tempfile
        self.count_lines = count_lines

    def check_if_missing(self):
        missing = []
        for cm in self.commands:
            if not cm.exists():
                missing.append(cm.binary_name)

        if missing:
            raise MissingCommands(missing)

    def run_once(self, cmd):
        if not cmd.exists():
            raise MissingCommands([cmd.binary_name])

        cmd.kwargs["stdout"] = subprocess.DEVNULL
        cmd.kwargs["cwd"] = self.directory

        start = time.time()
        res = cmd.run()
        end = time.time()


        line_count = None

        if self.count_lines:
            line_count = res.stdout.count(b'\n')

        return {
            'duration' : end - start,
            'line_count' : line_count
        }

    def run_once_with_temp_file(self, cmd):
        if not cmd.exists():
            raise MissingCommands([cmd.binary_name])

        cmd.kwargs["stdout"] = subprocess.DEVNULL
        cmd.kwargs["cwd"] = self.directory

       
        tmp = tempfile.NamedTemporaryFile()

        cmd.cmd.append(tmp.name)
        
        start = time.time()
        res = cmd.run()
        end = time.time()

        cmd.cmd.pop()

        line_count = None

        if self.count_lines:
            line_count = res.stdout.count(b'\n')

        return {
            'duration' : end - start,
            'line_count' : line_count
        }
    
    def run(self):
        self.check_if_missing()

        times = defaultdict(list)

        for cmd in self.commands:
            for _ in range(self.warmup):
                self.run_once(cmd)
            for _ in range(self.count):
                times[cmd.name].append(self.run_once(cmd)["duration"])

        return times

    def run_with_temp(self):
        self.check_if_missing()

        times = defaultdict(list)

        for cmd in self.commands:
            for _ in range(self.warmup):
                self.run_once_with_temp_file(cmd)
            for _ in range(self.count):
                times[cmd.name].append(self.run_once_with_temp_file(cmd)["duration"])

        return times

def bench_europarl_to_stdout(config, args):
    cmds = []

    if args.run in ["sort", "all"]:
        cmds.append(
            Command("sort", [SORT_PATH, "-u", BLOB_PATH])
        )
    if args.run in ["dedup", "all"]:
        cmds.append(
            Command("dedup", [DEDUP_BIN_PATH, BLOB_PATH])
        )
    if args.run in ["awk", "all"]:
        cmds.append(
            Command('awk', ['awk', '!seen[$0]++', BLOB_PATH])
        )

    bencher = Benchmarker(commands=cmds, **config)
    benches = bencher.run()

    for k, v in benches.items():
        print("{:8} - Fastest Run: {:<04.3}s  Average Run Time: {:<04.3}s  Stddev: {:<04.3}".format(k, min(v), mean(v), pstdev(v)))


def bench_europarl_to_tempfile(config, args):
    cmds = []

    if args.run in ["sort", "all"]:
        cmds.append(
            Command("sort", [SORT_PATH, "-u", BLOB_PATH, "-o"])
        )
    if args.run in ["dedup", "all"]:
        cmds.append(
            Command("dedup", [DEDUP_BIN_PATH, BLOB_PATH, "-o"])
        )

    bencher = Benchmarker(commands=cmds, **config)
    benches = bencher.run_with_temp()

    for k, v in benches.items():
        print("{:8} - Fastest Run: {:<04.3}s  Average Run Time: {:<04.3}s  Stddev: {:<04.3}".format(k, min(v), mean(v), pstdev(v)))


def download_and_pack_corpus(directory):
    corpus_archive = os.path.join(directory, CORPUS_NAME_GZ)
    corpus_unpacked = os.path.join(directory, CORPUS_UNPACK_DIR)
    blob_location = os.path.join(directory, BLOB_NAME)

    if not os.path.isdir(directory):
        os.makedirs(directory)
    if not os.path.exists(corpus_unpacked):
        if not os.path.exists(CORPUS_NAME_GZ):
            print("Downloading test corpus...")
            subprocess.run(['curl', '-LO', CORPUS_URL], cwd=directory)
        print("Unpacking test corpus...")
        subprocess.run(['tar', '-xzf', CORPUS_NAME_GZ], cwd=directory)

    if not os.path.exists(blob_location):
        print("Concatenating files in to single blob...")
        with open(blob_location, 'wb+') as f:
            for entry in os.listdir(corpus_unpacked):
                entry = os.path.join(corpus_unpacked, entry)
                if os.path.isfile(entry):
                    with gzip.open(entry, 'rb') as g:
                        f.write(g.read())

def build_dedup():
    print("Building dedup...")
    proj_path = os.path.abspath(os.path.join(os.path.dirname(__file__), os.path.pardir))
    subprocess.run(['cargo', 'build', '--release'], cwd=proj_path)


def main():
    p = argparse.ArgumentParser("Command line deduplication tool benchmark runner.")
    p.add_argument(
        '--warmup', metavar='INTEGER', type=int, default=1,
        help='The number of iterations to run each command before '
        'the actual measurements begin.')
    p.add_argument(
        '--benches', metavar='INTEGER', type=int, default=3,
        help='The number of samples to take when performing measurements.'
    )
    p.add_argument(
        '--sortpath', metavar='SORTPATH', default='sort'
    )
    p.add_argument(
        '--run', metavar='TESTNAME', choices=["awk", "dedup", "sort", "all"], nargs='?', default="all"
    )
    p.add_argument(
        '--dir', metavar='TESTDIR', default=BENCH_DIR
    )
    p.add_argument(
        '--use-tempfile', action='store_true'
    )
    args = p.parse_args()

    global SORT_PATH 
    SORT_PATH = args.sortpath

    config = dict()
    config["count"] = args.benches
    config["warmup"] = args.warmup
    config["directory"] = os.path.join(args.dir, TEST_DIR)
    config["use_tempfile"] = args.use_tempfile

    download_and_pack_corpus(config["directory"])

    if args.run in ["all", "dedup"]:
        build_dedup()

    global BLOB_PATH
    BLOB_PATH = os.path.join(config["directory"], BLOB_NAME)

    if not args.use_tempfile:
        bench_europarl_to_stdout(config, args)
    else:
        bench_europarl_to_tempfile(config, args)

if __name__ == '__main__':
    main()